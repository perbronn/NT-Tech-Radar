name,ring,quadrant,isNew,description
API expand-contract - oj oj oj ,Bruk,Techniques,TRUE,"<p>The <strong>API expand-contract</strong> pattern, sometimes called <a href=""https://www.martinfowler.com/bliki/ParallelChange.html"">parallel change</a>, will be familiar to many, especially when used with databases or code; however, we only see low levels of adoption with APIs. Specifically, we're seeing complex versioning schemes and breaking changes used in scenarios where a simple expand and then contract would suffice. For example, first adding to an API while deprecating an existing element, and then only later removing the deprecated elements once consumers are switched to the newer schema. This approach does require some coordination and visibility of the API consumers, perhaps through a technique such as <a href=""https://martinfowler.com/articles/consumerDrivenContracts.html"">consumer-driven contract</a> testing.</p>"
Continuous delivery for machine learning (CD4ML),Assess,kvadrant2,FALSE,"<p>We see <strong><a href=""https://martinfowler.com/articles/cd4ml.html"">continuous delivery for machine learning (CD4ML)</a></strong> as a good default starting point for any ML solution that is being deployed into production. Many organizations are becoming more reliant on ML solutions for both customer offerings and internal operations so it makes sound business sense to apply the lessons and good practice captured by <a href=""/radar/techniques/continuous-delivery-cd"">continuous delivery (CD)</a> to ML solutions.</p>"
Tool-managed Xcodeproj,Trial,Kvadrant 3,TRUE,"<p>Many of our developers coding iOS in Xcode often get headaches because the Xcodeproj file changes with every project change. The Xcodeproj file format is not human-readable, hence trying to handle merge conflicts is quite complicated and can lead to productivity loss and risk of messing up the entire project â€” if anything goes wrong with the file, Xcode won't work properly and developers will very likely be blocked. Instead of trying to merge and fix the file manually or version it, we recommend you use a <strong>tool-managed Xcodeproj</strong> approach: Define your Xcode project configuration in YAML (<a href=""https://github.com/yonaskolb/XcodeGen"">XcodeGen</a>, <a href=""https://github.com/lyptt/struct"">Struct</a>), Ruby (<a href=""https://github.com/igor-makarov/xcake"">Xcake</a>) or Swift (<a href=""https://github.com/tuist/tuist"">Tuist</a>). These tools generate the Xcodeproj file based on a configuration file and the project structure. As a result, merge conflicts in the Xcodeproj file will be a thing of the past, and when they do happen in the configuration file, they're much easier to handle.</p>"
UI/BFF shared types,Hold,Nummer 4,TRUE,"<p>With <a href=""/radar/languages-and-frameworks/typescript"">TypeScript</a> becoming a common language for front-end development and <a href=""/radar/platforms/node-js"">Node.js</a> becoming the preferred <a href=""/radar/techniques/bff-backend-for-frontends"">BFF</a> technology, we're seeing increasing use of <strong>UI/BFF shared types</strong>. In this technique, a single set of type definitions is used to define both the data objects returned by front-end queries and the data served to satisfy those queries by the back-end server. Ordinarily, we would be cautious about this practice because of the unnecessarily tight coupling it creates across process boundaries. However, many teams are finding that the benefits of this approach outweigh any risks of tight coupling. Since the BFF pattern works best when the same team owns both the UI code and the BFF, often storing both components in the same repository, the UI/BFF pair can be viewed as a single cohesive system. When the BFF offers strongly typed queries, the results can be tailored to the specific needs of the frontend rather than reusing a single, general-purpose entity that must serve the needs of many consumers and contain more fields than actually required. This reduces the risk of accidentally exposing data that the user shouldn't see, prevents incorrect interpretation of the returned data object and makes the query more expressive. This practice is particularly useful when implemented with <a href=""/radar/languages-and-frameworks/io-ts"">io-ts</a> to enforce the run-time type safety.</p>"